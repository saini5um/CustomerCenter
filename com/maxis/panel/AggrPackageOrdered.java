/*
 * AvailPackages.java
 *
 * Created on July 19, 2002, 7:42 AM
 */

package com.maxis.panel;

import com.csgsystems.igpa.utils.ContextFinder;
import com.csgsystems.igpa.controls.models.*;

import javax.swing.tree.*;
import javax.swing.event.*;
import java.util.*;

import com.csgsystems.domain.framework.*;
import com.csgsystems.domain.framework.businessobject.*;
import com.csgsystems.domain.framework.context.*;
import com.csgsystems.domain.framework.criteria.*;
import com.csgsystems.domain.arbor.order.*;
import com.csgsystems.domain.arbor.utilities.DomainUtility;

import com.csgsystems.bp.utilities.TemplateUtility;

/**
 *
 * @author  prev01
 */

public class AggrPackageOrdered extends javax.swing.JPanel implements TreeSelectionListener {

    protected boolean m_bHasBeenInitialized = false;
    
    /**
     *  Instance of the ContextFinder utility class, which can recursively
     *  search up the component hierarchy for an ICSGContextForm, and then
     *  retrieve its context (cached for later use).
     */
    private ContextFinder ctxFinder = new ContextFinder(this);

    
    /**
     * Description of the Field: This indicates the Panel collection class is a ProductPackageList
     */
    public final static int PRODUCT_PACKAGE_LIST = 1;
    /**
     * Description of the Field: This indicates the Panel collection class is a PackageDefinitionList
     */
    public final static int PACKAGE_DEFINITION_LIST = 2;

    /**
     * Description of the Field: This is an indicator to show the type
     * of collection class used by this panel.
     */
    private int m_OrderedCollectionType = 0;


    // Indicator for Packages with only AccountLevel components.
    private boolean m_CanDisplayWithOnlyAccountLevel = true;
    // Indicator for Packages with only ServiceLevel components.
    private boolean m_CanDisplayWithOnlyServiceLevel = true;
    // Indicator for Packages with Required ServiceLevel components.
    private boolean m_CanDisplayWithRequiredServiceLevel = true;


    public AggrPackageOrdered() {
        initComponents();
        
        // Set Up Tree
        treePackage.setModelInfo(buildAccountPackagesTreeXMLDefinition());  
        treePackage.setCellRenderer(new ObjectStateTreeCellRenderer());
        treePackage.addTreeSelectionListener(this);
    }

    public void addHyperlinkListener(javax.swing.event.HyperlinkListener listener) {
        velOrderedComponents.addHyperlinkListener(listener); 
        velOrderedComponents.addExtraVelocityContextTopic("TemplateUtility", new TemplateUtility());
    }

    public void setCanDisplayWithOnlyAccountLevel(boolean indicator) {
        // Indicate that Packages with only AccountLevel components should display Components for that Package.
        // If this indicator is set to false, none of the Components will be displayed for the Package.
        m_CanDisplayWithOnlyAccountLevel = indicator;
    }

    public void setCanDisplayWithOnlyServiceLevel(boolean indicator) {
        // Indicate that Packages with only ServiceLevel components should display Components for that Package.
        // If this indicator is set to false, none of the Components will be displayed for the Package.
        m_CanDisplayWithOnlyServiceLevel = indicator;
    }

    public void setCanDisplayWithRequiredServiceLevel(boolean indicator) {
        // Indicate that Packages with Required ServiceLevel Components should display Components for that Package.
        // If this indicator is set to false, none of the Components will be displayed for the Package.
        m_CanDisplayWithRequiredServiceLevel = indicator;
    }

    /**
     * Set the Display .
     */
    public void setOrderedCollectionType(int orderedCollectionType) {
        m_OrderedCollectionType = orderedCollectionType;
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        java.awt.GridBagConstraints gridBagConstraints;

        spnlCurrent = new javax.swing.JSplitPane();
        spPackage = new javax.swing.JScrollPane();
        treePackage = new com.csgsystems.igpa.controls.CSGCollectionTree();
        velOrderedComponents = new com.csgsystems.igpa.controls.CSGVelocityHTMLEP();

        setLayout(new java.awt.GridBagLayout());

        setPreferredSize(new java.awt.Dimension(645, 235));
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentShown(java.awt.event.ComponentEvent evt) {
                formComponentShown(evt);
            }
        });

        spnlCurrent.setBorder(null);
        spnlCurrent.setDividerLocation(475);
        spnlCurrent.setDividerSize(5);
        treePackage.setDomainName("Account");
        spPackage.setViewportView(treePackage);

        spnlCurrent.setLeftComponent(spPackage);

        velOrderedComponents.setBorder(null);
        velOrderedComponents.setPreferredSize(new java.awt.Dimension(50, 50));
        velOrderedComponents.setVelocityTemplateUri("template/PackageOrderedComponents.vm");
        velOrderedComponents.setAutoscrolls(true);
        spnlCurrent.setRightComponent(velOrderedComponents);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        add(spnlCurrent, gridBagConstraints);

    }//GEN-END:initComponents

    private void formComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentShown
        // The TabPanel is displayed, so retrieve the new Packages that have not yet been persisted.

        IContext context = ctxFinder.findContext();
        if (context != null) {
            IPersistentObject account = context.getObject("Account");
            if (m_OrderedCollectionType == PRODUCT_PACKAGE_LIST) {
                if (account != null) {
                    // This is for AccountChange and ServiceChange Wizards
                    IPersistentCollection productPackageList = account.getCollection("ProductPackageList", "Account");
                    IPersistentCollection orderedProductPackageList = account.getCollection("ProductPackageList", "Ordered");
                    orderedProductPackageList.reset();

                    if (productPackageList != null && orderedProductPackageList != null) {
                        Iterator iterator = productPackageList.iterator();
                        while (iterator.hasNext()) {
                            IPersistentObject productPackage = (IPersistentObject)iterator.next();
                            if (productPackage != null && productPackage.isNewObject() == true) {
                                boolean addToList = true;
                                // Spin thru our objects in the list to see if we've already got this reference.
                                // We're doing a this pointer comparison, because the objects may be the same, and
                                // we need to be able to tell specific references from each other.
                                int orderedCount = orderedProductPackageList.getCount();
                                for (int j=0; j<orderedCount; j++) {
                                    IPersistentObject productPackageInList = orderedProductPackageList.getAt(j);
                                    if (productPackage == productPackageInList) {
                                        addToList = false;
                                    }
                                }
                                if (addToList == true) {
                                    // If this PackageDefinition is not already in the list, add it.
                                    orderedProductPackageList.add(productPackage);
                                }
                            }
                        }
                    }
                }
            } else if (m_OrderedCollectionType == PACKAGE_DEFINITION_LIST) {
                // This is for NewCustomerAquisition and ServiceAdd Wizards
                IPersistentObject transientShoppingCart = context.getObject("TransientShoppingCart", null);
                if (account != null && transientShoppingCart != null) {
                    IPersistentCollection orderedPackageDefinitionList = account.getCollection("PackageDefinitionList", "Ordered");
                    orderedPackageDefinitionList.reset();

                    if (orderedPackageDefinitionList != null) {
 
                        // Retrieve the currently ordered Packages and put into our lists
                        IPersistentCollection packageComponentDefList = transientShoppingCart.getCollection("PackageComponentDefList", "TransientShoppingCart");
                        if (packageComponentDefList != null) {
                            int count = packageComponentDefList.getCount();
                            for (int i=0; i<count; i++) {
                                IPersistentObject packageComponentDef = packageComponentDefList.getAt(i);
                                if (packageComponentDef != null) {
                                    IPersistentObject packageDefinition = packageComponentDef.getObject("PackageDefinition", "PackageComponentDef");
                                    if (packageDefinition != null && packageDefinition.isNewObject() == true) {
                                        boolean addToList = true;
                                        // Spin thru our objects in the list to see if we've already got this reference.
                                        // We're doing a this pointer comparison, because the objects may be the same, and
                                        // we need to be able to tell specific references from each other.
                                        int orderedCount = orderedPackageDefinitionList.getCount();
                                        for (int j=0; j<orderedCount; j++) {
                                            IPersistentObject packageDefinitionInList = orderedPackageDefinitionList.getAt(j);
                                            if (packageDefinition == packageDefinitionInList) {
                                                addToList = false;
                                            }
                                        }
                                        if (addToList == true) {
                                            // If this PackageDefinition is not already in the list, add it.
                                            orderedPackageDefinitionList.add(packageDefinition);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        // Need to re-initialize the tree after adding ... and before changing visible account, below
        treePackage.setModelInfo(buildAccountPackagesTreeXMLDefinition());
        treePackage.initializeControl();
    }//GEN-LAST:event_formComponentShown

    public void valueChanged(javax.swing.event.TreeSelectionEvent treeSelectionEvent) {
        TreePath treePath = treeSelectionEvent.getNewLeadSelectionPath();
        if (treePath != null && treePath.getPathCount() == 2) {
            TreePath selectedPath = treePackage.getSelectionPath();
            if (selectedPath != null) {
                CollectionTreeNode node = (CollectionTreeNode) selectedPath.getLastPathComponent();
                if (node != null) {
                    IPersistentObject pTargetDom = node.getObject();
                    if (pTargetDom == null) {
                        System.out.println("Could not Get ProductPackage from Tree");
                    } else {
        
                        // Create Package Component collection 
                        IPersistentCollection packageComponentDefList = (IPersistentCollection) PersistentObjectFactory.getFactory().createNew("PackageComponentDefList", "OrderedPackageComponents");
        
                        // Create search parameter
                        java.util.HashMap params = new java.util.HashMap();
                        QueryCriteria qc = new QueryCriteria();
                        qc.setFilterCriteria(FilterCriteria.createEquals(pTargetDom.getAttributeData("PackageId")));
                        params.put("PackageId", qc);
        
                        DomainUtility.setLanguageCodeFilter(params);

                        IPersistentObject pOrder = OrderManager.getInstance().getCurrentOrder();
                        if (pOrder != null) {
                            qc = new QueryCriteria();
                            qc.setFilterCriteria(FilterCriteria.createLessThan(pOrder.getAttributeData("EffectiveDate")));
                            params.put("PackageActiveDt", qc);

                            qc = new QueryCriteria();
                            qc.setFilterCriteria(FilterCriteria.createGreaterThanEqual(pOrder.getAttributeData("EffectiveDate")));
                            qc.addFilterCriteria(FilterCriteria.createIsNull());
                            params.put("PackageInactiveDt", qc);

                            qc = new QueryCriteria();
                            qc.setFilterCriteria(FilterCriteria.createLessThan(pOrder.getAttributeData("EffectiveDate")));
                            params.put("ActiveDt", qc);

                            qc = new QueryCriteria();
                            qc.setFilterCriteria(FilterCriteria.createGreaterThanEqual(pOrder.getAttributeData("EffectiveDate")));
                            qc.addFilterCriteria(FilterCriteria.createIsNull());
                            params.put("InactiveDt", qc);
                        }
                        
                        qc = new QueryCriteria();
                        qc.setSortCriteria(new SortCriteria((short)0, true)); // Ascending sort
                        params.put("DisplayValue", qc);
                        
                        packageComponentDefList.setSearchParameters(params);
                        packageComponentDefList.reset();
        
                        // This indicates if there are ONLY AccountLevel components within this package          
                        boolean isAccountLevelOnly = true;
                        // This indicates if there are ONLY ServiceLevel components within this package          
                        boolean isServiceLevelOnly = true;
                        // This indicates if there are Required ServiceLevel components within this package          
                        boolean foundRequiredServiceLevel = false;

                        // If we can display everything, don't bother with this checking.  
                        if (!m_CanDisplayWithOnlyAccountLevel || !m_CanDisplayWithRequiredServiceLevel) {
                  
                            int count = packageComponentDefList.getCount();
                            for (int i=0; i<count; i++) {
                                IPersistentObject packageComponentDef = packageComponentDefList.getAt(i);
                                if (packageComponentDef != null) {
                                    int levelCode = packageComponentDef.getAttributeDataAsInteger("ComponentLevel");
                                    if (levelCode == 2) {
                                        // This package has a ServiceLevel only component within it,
                                        // therefore it is not an AccountLevel Only Package
                                        isAccountLevelOnly = false;

                                        // Check the Required ServiceLevel components
                                        int minRequired = packageComponentDef.getAttributeDataAsInteger("MinimumRequired");
                                        if (minRequired > 0 && !m_CanDisplayWithRequiredServiceLevel) {
                                            // This ServiceLevel component is Required but we're not supposed to
                                            // show Package Components with RequiredLevel components, so don't display any.
                                            foundRequiredServiceLevel = true;
                                        }
                                    } else {
                                        // This package has an AccountLevel component within it,
                                        // therefore it is not a ServiceLevel Only Package
                                        isServiceLevelOnly = false;
                                    }
                                }
                            }
                        }
            

                        IContext ctx = ctxFinder.findContext();
                        if (ctx != null) {
                            // Check to see if we can display Components for the Package that only have AccountLevel Components
                            // If we can't, then see if this is a Package that has only AccountLevel components and don't display if it is.
                            // Also, if we are not supposed to display Required ServiceLevel components, make sure there are none in the Package.
                            if ((m_CanDisplayWithOnlyAccountLevel && m_CanDisplayWithRequiredServiceLevel) ||
                                (!isServiceLevelOnly && !m_CanDisplayWithRequiredServiceLevel && !foundRequiredServiceLevel) ||
                                (!m_CanDisplayWithOnlyAccountLevel && !isAccountLevelOnly)) {
                                ctx.addTopic((IPersistentObject)packageComponentDefList);
                            } else {
                                ctx.removeTopic((IPersistentObject)packageComponentDefList);
                            }
                        }

                        velOrderedComponents.initializeControl();
                    }
                }
            }
        } else {
            IContext ctx = ctxFinder.findContext();
            if (ctx != null) {
                IPersistentCollection packageComponentDefList = ctx.getCollection("PackageComponentDefList", "OrderedPackageComponents");
                if (packageComponentDefList != null) {
                    ctx.removeTopic((IPersistentObject)packageComponentDefList);
                    velOrderedComponents.initializeControl();
                }
            }
        }
    }

    /**
     * Builds the xml definition for the Packages tree.
     * Created this way because we want to show the number of packages currently in the working set.
     */
    private String buildAccountPackagesTreeXMLDefinition() {

        String xmlDef = new String();

        if (m_OrderedCollectionType == PRODUCT_PACKAGE_LIST) {
            // Tree definition for ProductPackage objects that have already been Associated to the Account
            xmlDef = "<?xml version=\"1.0\"?>" +
                        "<csg-tree>" +
                            "<node>" +
                               "<label column-formatter-name=\"com.csgsystems.domain.arbor.formatter.AccountDescriptionFormatter\" />" +
                               "<children>" +
                                  "<data-set name=\"ProductPackageList\" subtype=\"Ordered\">" +
                                     "<node>" +
                                         //"<label column-name=\"PackageId\" />" +
                                         "<label column-formatter-name=\"com.csgsystems.domain.arbor.formatter.ProductPackageDescriptionFormatter\" />" +
                                     "</node>" +
                                  "</data-set>" +
                               "</children>" +
                            "</node>" +
                        "</csg-tree>";
        } else if (m_OrderedCollectionType == PACKAGE_DEFINITION_LIST){
            // Tree definition for PackageDefinition objects that have not yet been Associated to the Account
            xmlDef = "<?xml version=\"1.0\"?>" +
                        "<csg-tree>" +
                            "<node>" +
                               "<label column-formatter-name=\"com.csgsystems.domain.arbor.formatter.AccountDescriptionFormatter\" />" +
                               "<children>" +
                                  "<data-set name=\"PackageDefinitionList\" subtype=\"Ordered\">" +
                                     "<node>" +
                                         //"<label column-name=\"DisplayValue\" />" +
                                        "<label column-formatter-name=\"com.csgsystems.domain.arbor.formatter.PackageDefinitionDescriptionFormatter\" />" +
                                     "</node>" +
                                  "</data-set>" +
                               "</children>" +
                            "</node>" +
                        "</csg-tree>";
        } else {
            // Default Tree definition
            xmlDef = "<?xml version=\"1.0\"?>" +
                        "<csg-tree>" +
                            "<node>" +
                               "<label column-formatter-name=\"com.csgsystems.domain.arbor.formatter.AccountDescriptionFormatter\" />" +
                            "</node>" +
                        "</csg-tree>";
        }

        return xmlDef;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane spPackage;
    private javax.swing.JSplitPane spnlCurrent;
    protected com.csgsystems.igpa.controls.CSGCollectionTree treePackage;
    private com.csgsystems.igpa.controls.CSGVelocityHTMLEP velOrderedComponents;
    // End of variables declaration//GEN-END:variables
    
}
